#!/bin/busybox sh

# Exit if an error occurs or an unset variable is referenced.
set -euo pipefail

# By default, don't let `acme.sh` create files accessible to anyone but itself.
umask 0007

# Get our mail server's hostname (e.g. `mail.example.com`).
hostname="$(hostname)"

# Load the Cloudflare API token from our Docker secrets so `acme.sh` can use it.
cf_api_token="$(cat /run/secrets/CF_API_TOKEN)"

# Set the Postfix TLS chain file path to the same one used in the `postfix-tls`
# Docker volume defined in `compose.yaml`.
postfix_tls_path=/etc/postfix/smtpd_tls_chain_files

# * Use `acme.sh` to issue a new TLS certificate.
# * Use our domain's DNS records in Cloudflare to prove to Let's Encrypt that we
#   own the domain we're requesting a certificate for.
# * Generate a new private key for each renew to limit the risk of a compromised
#   key.
# * Upon renewal, copy the new private key and certificate files to the location
#   we configured Postfix to use (in `etc/postfix/main.cf`), since the location
#   `acme.sh` saves to by default is intentionally unreliable.
# * Tell `acme.sh` to reload Postfix whenever it renews our certificate so that
#   Postfix always uses the latest certificate files.
CF_Token="$cf_api_token" \
acme.sh \
	--issue \
	--dns dns_cf \
	--domain "$hostname" \
	--always-force-new-domain-key \
	--key-file "$postfix_tls_path/key.pem" \
	--fullchain-file "$postfix_tls_path/cert.pem" \
	--renew-hook "postfix reload" ||
	# Do nothing (don't exit this script) if the above command fails, for
	# example due to existing certificates not needing renewal yet.
	:

# Exit this script if the above files failed to generate, with a nice error
# message generated by `ls`.
ls "$postfix_tls_path/key.pem" 1> /dev/null
