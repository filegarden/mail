#!/bin/bash

# Exit if an error occurs or an unset variable is referenced.
set -euo pipefail

# By default, don't give created files access to anyone but the `acme` user this
# script runs as.
umask 0077

# Each line in this file has information about a DNS record this script created
# but still needs to delete.
dns_cleanup_path="$BASEDIR/cf_dns_cleanup"

# Makes a request to the Cloudflare API.
cf_api() {
	local path="$1"
	# Shift off `$1` from this function's arguments so `$@` can refer to all
	# the arguments except `$path`.
	shift

	local cf_api_base_url
	cf_api_base_url=https://api.cloudflare.com/client/v4

	# Load the Cloudflare API token from our Docker secrets.
	local cf_api_token
	cf_api_token="$(< /run/secrets/CF_API_TOKEN)"

	local response_json
	response_json="$(
		curl -s "$cf_api_base_url$path" \
			-H "Authorization: Bearer $cf_api_token" \
			"$@"
	)"

	# Output any errors from the API response.
	jq -cr '.errors[]' <<< "$response_json" |
	while read -r error; do
		echo "ERROR: $error" >&2
	done

	# If the request wasn't successful, exit the script.
	if [[ "$(jq '.success' <<< "$response_json")" != "true" ]]; then
		exit 1
	fi

	echo "$response_json"
}

# Gets the Cloudflare zone ID for a domain.
get_zone_id() {
	local domain="$1"

	local zone_id
	zone_id="$(
		cf_api /zones --url-query "name=$domain" |
		jq -r '.result[0].id'
	)" || exit 1

	if [[ "$zone_id" == "null" ]]; then
		# If no zone is found, try again with one subdomain component
		# removed. For example, Cloudflare won't find a zone for
		# `mail.example.com`, but it can find a zone for `example.com`.
		domain_without_subdomain="${domain#*.}"

		# This is the initial domain from before any subdomain
		# components were removed.
		initial_domain="${INITIAL_DOMAIN:-$domain}"

		# If removing a component from the domain results in a string
		# with no periods, it's not even a valid domain anymore, so the
		# failure to find a zone isn't merely a result of a subdomain's
		# presence.
		if [[ "$domain_without_subdomain" != *.* ]]; then
			echo "ERROR: No Cloudflare zone found for domain '$initial_domain'." >&2
			exit 1
		fi

		# Call this function again with one subdomain component removed.
		INITIAL_DOMAIN="$initial_domain" \
		get_zone_id "$domain_without_subdomain"
		return 0
	fi

	echo "$zone_id"
}

# Deletes a DNS record and removes its information from our DNS cleanup file.
clean_dns_record() {
	local zone_id="$1" dns_record_name="$2" token_value="$3"

	local dns_record_id
	dns_record_id="$(
		cf_api "/zones/$zone_id/dns_records" \
			--url-query "type=TXT" \
			--url-query "name=$dns_record_name" \
			--url-query "content=$token_value" |
		jq -r '.result[0].id'
	)" || exit 1

	# Only try to delete the DNS record if it was found.
	if [[ "$dns_record_id" != "null" ]]; then
		cf_api "/zones/$zone_id/dns_records/$dns_record_id" \
			-X DELETE > /dev/null
	fi

	# Get all the DNS record info passed into this function's arguments.
	local dns_record_info
	dns_record_info="$*"

	# Escape it so it can be safely used in a regex pattern.
	local escaped_dns_record_info
	escaped_dns_record_info="$(
		printf '%s' "$dns_record_info" | sed -e 's/[$*./[\^]/\\&/g'
	)"

	# Now that the DNS record is deleted, remove its information from our
	# DNS cleanup file.
	sed -i "/^$escaped_dns_record_info$/d" "$dns_cleanup_path"
}

# Deletes any DNS records previously created by this script that never got
# cleaned up.
clean_old_challenges() {
	# Create our DNS cleanup file if it doesn't already exist.
	touch "$dns_cleanup_path"

	# Read each line from our DNS cleanup file, and split each line's words
	# into a Bash array.
	local dns_record_info
	while read -ra dns_record_info; do
		# Pass the words in the array as arguments to our DNS cleanup
		# function.
		clean_dns_record "${dns_record_info[@]}"
	done < "$dns_cleanup_path"
}

# `dehydrated` runs this before a domain is validated.
deploy_challenge() {
	# These arguments are passed in by `dehydrated`.
	local domain="$1" token_value="$3"

	# Create the `_acme-challenge` DNS record requested by `dehydrated`.

	local zone_id
	zone_id="$(get_zone_id "$domain")" || exit 1

	local dns_record_name
	dns_record_name="_acme-challenge.$domain"

	local dns_record_comment
	dns_record_comment="This record should be deleted automatically. If it isn't, feel free to delete it."

	local dns_record_data
	dns_record_data='{"type":"TXT","name":"'"$dns_record_name"'","content":"'"$token_value"'","comment":"'"$dns_record_comment"'"}'

	# Save some information about the DNS record we'll create. That way, for
	# example if the container stops in the middle of the ACME challenge, we
	# don't lose this information, and we can still remove the record.
	echo "$zone_id $dns_record_name $token_value" >> "$dns_cleanup_path"

	cf_api "/zones/$zone_id/dns_records" \
		-X POST \
		-H "Content-Type: application/json" \
		--data-raw "$dns_record_data" > /dev/null

	echo "Waiting 20 seconds for DNS records to propagate..."
	sleep 20
}

# `dehydrated` runs this after a domain is validated.
clean_challenge() {
	# These arguments are passed in by `dehydrated`.
	local domain="$1" token_value="$3"

	local zone_id
	zone_id="$(get_zone_id "$domain")" || exit 1

	local dns_record_name
	dns_record_name="_acme-challenge.$domain"

	clean_dns_record "$zone_id" "$dns_record_name" "$token_value"
}

# `dehydrated` runs this after our certificates are renewed.
deploy_cert() {
	# These arguments are passed in by `dehydrated`.
	local keyfile="$2" fullchainfile="$4"

	# Set the Postfix TLS chain file path to the directory used in the
	# `smtpd_tls_chain_files` option from `etc/postfix/main.cf`.
	postfix_tls_path=/etc/postfix/smtpd_tls_chain_files

	cat "$keyfile" > "$postfix_tls_path/privkey.pem"
	cat "$fullchainfile" > "$postfix_tls_path/fullchain.pem"

	# Reload Postfix after renewal so it can use the updated TLS files.
	postfix reload
}

# `dehydrated` runs this on each attempt to issue certificates before running
# anything else in this script.
startup_hook() {
	# Delete any DNS records previously created by this script that never
	# got cleaned up.
	clean_old_challenges
}

case "$1" in
deploy_challenge | clean_challenge | deploy_cert | startup_hook)
	"$@"
	;;
esac
