#!/bin/busybox sh

# Exit if an error occurs or an unset variable is referenced.
set -euo pipefail

# The specified sender domain to check DNS records for.
sender_domain="$1"

reset="$(printf '\e[0m')"
lblue="$(printf '\e[1;34m')"

# Fetch our Cloudflare zone information.
zone_json="$(cf zone)"
zone_id="$(printf '%s\n' "$zone_json" | jq -r '.id')"
zone_name="$(printf '%s\n' "$zone_json" | jq -r '.name')"

# A variable for whether our token has access to the sender domain.
can_modify_dns=

# Check if the sender domain (`$sender_domain`) is under the domain of the zone
# our token has access to (`$zone_name`).
if [[ ".$sender_domain" == *".$zone_name" ]]; then
	can_modify_dns=y
fi

# Get our mail server's hostname (e.g. `mail.example.com`).
hostname="$(hostname)"

# The domain name all our DNS records are under which the sender domain should
# reference.
source_domain="$hostname"

# If our source domain name (`$source_domain`) is outside the domain of the zone
# our token has access to (`$zone_name`), correct the source domain name to be
# under our zone.
if [[ ".$source_domain" != *".$zone_name" ]]; then
	source_domain="$source_domain.$zone_name"
fi

# Ensures the sender's DKIM record with the specified DKIM selector is an alias
# of our server's.
_check_dkim() {
	local selector="$1"

	# This is our original DKIM record that the sender domains's DKIM record
	# should point to.
	local source_dns_record_name="$selector._domainkey.$source_domain"

	# The name of the DNS record we're checking.
	local dns_record_name="$selector._domainkey.$sender_domain"

	# If the DKIM DNS record we're checking is already the source record,
	# there's no need to ensure the former is an alias of the latter.
	if [[ "$dns_record_name" == "$source_dns_record_name" ]]; then
		return 0
	fi

	# Get the value of the CNAME record (if it exists) for the specified
	# DKIM key.
	local cname
	cname="$(
		cf dns query CNAME "$dns_record_name" | jq -r '.Answer[0].data'
	)"

	# If the CNAME value already points to our server's DKIM record, no need
	# to continue.
	if [[ "$cname" == "$source_dns_record_name." ]]; then
		return 0
	fi

	# If we can't modify the DNS automatically, output an error with
	# instructions to modify it manually.
	if [[ ! "$can_modify_dns" ]]; then
		cat <<-END >&2
		ERROR: The following DNS record must be set for ${lblue}$sender_domain${reset}:

		Type: ${lblue}CNAME${reset}

		Name: ${lblue}$dns_record_name${reset}

		Target: ${lblue}$source_dns_record_name${reset}

		Proxy status: ${lblue}DNS only${reset}
		END
		exit 1
	fi

	# We can modify the DNS automatically.

	# Fetch information for the DNS record we're modifying. If no such
	# record exists, this will be `null`.
	local dns_record_json
	dns_record_json="$(
		cf api "/zones/$zone_id/dns_records" \
			--url-query "type=CNAME" \
			--url-query "name=$dns_record_name" \
		| jq '.result[0]'
	)"

	# If the DNS record doesn't exist, create it.
	if [[ "$dns_record_json" == "null" ]]; then
		printf '%s\n' "Creating DNS record at '$dns_record_name'..."

		local dns_record_data='{"type":"CNAME","name":"'"$dns_record_name"'","content":"'"$source_dns_record_name"'"}'

		cf api "/zones/$zone_id/dns_records" \
			-X POST \
			-H "Content-Type: application/json" \
			--data-raw "$dns_record_data" > /dev/null

		return 0
	fi

	# Since the record already exists, make a request to modify it.

	local dns_record_id
	dns_record_id="$(printf '%s\n' "$dns_record_json" | jq -r '.id')"

	printf '%s\n' "Updating DNS record at '$dns_record_name'..."

	local dns_record_patch='{"content":"'"$source_dns_record_name"'"}'

	cf api "/zones/$zone_id/dns_records/$dns_record_id" \
		-X PATCH \
		-H "Content-Type: application/json" \
		--data-raw "$dns_record_patch" > /dev/null
}

# Ensures the sender's SPF record includes our server's.
_check_spf() {
	# This is our original SPF record that sender's SPF record should
	# include. The name of this record is chosen in our `check_dns` script,
	# where the record is originally created.
	local source_dns_record_name="_spf.$source_domain"

	# The name of the DNS record we're checking.
	local dns_record_name="$sender_domain"

	# If the SPF DNS record we're checking is already the source record,
	# there's no need to ensure the former includes the latter.
	if [[ "$dns_record_name" == "$source_dns_record_name" ]]; then
		return 0
	fi

	# Get all the TXT record values under the sender's domain. Remove quotes
	# because quotes are allowed around parts of a TXT record's data. Then
	# filter the list to only contain SPF records. If no SPF records are
	# found, do nothing instead of letting `grep` exit with an error.
	local spf_data
	spf_data="$(
		cf dns query TXT "$dns_record_name" \
		| jq -r '.Answer[]?.data' \
		| tr -d '"' \
		| { grep -E '^v=spf1( |$)' || :; }
	)"

	# Check if there are multiple SPF records.
	if [[ "$spf_data" == *$'\n'* ]]; then
		printf '%s\n' "ERROR: Multiple TXT DNS records starting with 'v=spf1' found at '$dns_record_name'. There must be only one SPF record." >&2
		exit 1
	fi

	# This will be the value the sender domain's SPF record should have.
	# Start with its existing SPF record value so its preexisting policies
	# (e.g. allowing other mail servers to send for the domain) aren't lost.
	# If there is no existing SPF record, default to an empty SPF policy.
	local correct_spf_data="${spf_data:-v=spf1}"

	# An SPF term that includes our server's own SPF policy into another
	# domain's SPF policy.
	local include="include:$source_dns_record_name"

	# If the sender domain's SPF policy doesn't include our server's own SPF
	# policy, include it so we're allowed to send mail for that domain.
	if ! printf '%s\n' "$correct_spf_data" | grep -Fiqw "$include"; then
		# Insert our `include:` term after the `v=spf1` (starting at
		# index 0, ending 6 characters later) and before the rest of the
		# terms (starting at index 6).
		correct_spf_data="${correct_spf_data:0:6} $include${correct_spf_data:6}"
	fi

	# Remove any preexisting `all` term from the policy, and add the correct
	# one. There should be an `all` term with the `-` (fail) qualifier so
	# all servers not explicitly covered by the policy are disallowed from
	# sending for the domain. Only authorized senders should be allowed.
	#
	# RFC 7208 (section 4.6.2) lists all SPF qualifiers.
	correct_spf_data="$(
		printf '%s\n' "$correct_spf_data" | sed -E 's/ [+-?~]?all$//gi'
	) -all"

	# If the SPF value is already correct, no need to continue.
	if [[ "$spf_data" == "$correct_spf_data" ]]; then
		return 0
	fi

	# If we can't modify the DNS automatically, output an error with
	# instructions to modify it manually.
	if [[ ! "$can_modify_dns" ]]; then
		cat <<-END >&2
		ERROR: The following DNS record must be set for ${lblue}$sender_domain${reset}:

		Type: ${lblue}TXT${reset}

		Name: ${lblue}$dns_record_name${reset}

		Content: ${lblue}$correct_spf_data${reset}

		Proxy status: ${lblue}DNS only${reset}
		END
		exit 1
	fi

	# We can modify the DNS automatically.

	# Fetch information for the DNS record we're checking. If no such record
	# exists, this will be `null`.
	#
	# To find the SPF record, this queries for all TXT records with the same
	# name as the SPF record. Then it filters the results for just the first
	# one whose first term is `v=spf1`, indicating it's an SPF record.
	local dns_record_json
	dns_record_json="$(
		cf api "/zones/$zone_id/dns_records" \
			--url-query "type=TXT" \
			--url-query "name=$dns_record_name" \
		| jq '
			.result
			| map(select(.content | test("^v=spf1( |$)")))
			| first
		'
	)"

	# If the DNS record doesn't exist, create it.
	if [[ "$dns_record_json" == "null" ]]; then
		printf '%s\n' "Creating DNS record for SPF at '$dns_record_name'..."

		local dns_record_data='{"type":"TXT","name":"'"$dns_record_name"'","content":"'"$correct_spf_data"'"}'

		cf api "/zones/$zone_id/dns_records" \
			-X POST \
			-H "Content-Type: application/json" \
			--data-raw "$dns_record_data" > /dev/null

		return 0
	fi

	# Since the record already exists, make a request to modify it.

	local dns_record_id
	dns_record_id="$(printf '%s\n' "$dns_record_json" | jq -r '.id')"

	printf '%s\n' "Updating DNS record for SPF at '$dns_record_name'..."

	local dns_record_patch='{"content":"'"$correct_spf_data"'"}'

	cf api "/zones/$zone_id/dns_records/$dns_record_id" \
		-X PATCH \
		-H "Content-Type: application/json" \
		--data-raw "$dns_record_patch" > /dev/null
}

# Ensure the sender's domain points to both of our DKIM keys.
_check_dkim a
_check_dkim b

# Ensure the sender's domain points to our SPF policy.
_check_spf
