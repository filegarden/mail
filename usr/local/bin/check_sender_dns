#!/bin/busybox sh

# Exit if an error occurs or an unset variable is referenced.
set -euo pipefail

# The specified sender domain to check DNS records for.
sender_domain="$1"

reset="$(printf '\e[0m')"
lblue="$(printf '\e[1;34m')"

# Fetch our Cloudflare zone information.
zone_json="$(cf zone)"
zone_id="$(printf '%s\n' "$zone_json" | jq -r '.id')"
zone_name="$(printf '%s\n' "$zone_json" | jq -r '.name')"

# A variable for whether our token has direct access to the sender domain.
can_access_dns=

# Check if the sender domain (`$sender_domain`) is under the domain of the zone
# our token has access to (`$zone_name`).
if [[ ".$sender_domain" == *".$zone_name" ]]; then
	can_access_dns=y
fi

# Get our mail server's hostname (e.g. `mail.example.com`).
hostname="$(hostname)"

# The domain name all our DNS records are under which the sender domain should
# reference.
source_domain="$hostname"

# If our source domain name (`$source_domain`) is outside the domain of the zone
# our token has access to (`$zone_name`), correct the source domain name to be
# under our zone.
if [[ ".$source_domain" != *".$zone_name" ]]; then
	source_domain="$source_domain.$zone_name"
fi

# Ensures the sender's DKIM record with the specified DKIM selector is an alias
# of our server's.
_check_dkim() {
	local selector="$1"

	# This is our original DKIM record that the sender domains's DKIM record
	# should point to.
	local source_dns_record_name="$selector._domainkey.$source_domain"

	# The name of the DNS record we're checking.
	local dns_record_name="$selector._domainkey.$sender_domain"

	# If the DKIM DNS record we're checking is already the source record,
	# there's no need to ensure the former is an alias of the latter.
	if [[ "$dns_record_name" == "$source_dns_record_name" ]]; then
		return 0
	fi

	# This variable will hold information for the DNS record we're checking.
	# If no such record exists, this will be `null`.
	local dns_record_json

	# This variable will hold the value of the DNS record we're checking. If
	# no such record exists, this will be `null`.
	local cname

	# If we have direct DNS access via the Cloudflare API, get the record
	# information from there since it's the most up-to-date source and
	# provides more information about the records that we might need later.
	# If we don't have API access, get it using a DNS query.
	if [[ "$can_access_dns" ]]; then
		dns_record_json="$(
			cf api "/zones/$zone_id/dns_records" \
				--url-query "type=CNAME" \
				--url-query "name=$dns_record_name" \
			| jq '.result[0]'
		)"

		cname="$(printf '%s\n' "$dns_record_json" | jq -r '.content')"
	else
		cname="$(
			cf dns query CNAME "$dns_record_name" \
			| jq -r '.Answer[0].data'
		)"

		# DNS query answers for CNAME records explicitly include a `.`
		# at the end. The Cloudflare API always omits the trailing `.`,
		# so trim it off here to be consistent with that.
		cname="${cname%.}"
	fi

	# If the CNAME value already points to our server's DKIM record, no need
	# to continue.
	if [[ "$cname" == "$source_dns_record_name" ]]; then
		return 0
	fi

	# If we can't modify the DNS automatically, output an error with
	# instructions to modify it manually.
	if [[ ! "$can_access_dns" ]]; then
		cat <<-END >&2
		ERROR: The following DNS record must be set for ${lblue}$sender_domain${reset}:

		Type: ${lblue}CNAME${reset}

		Name: ${lblue}$dns_record_name${reset}

		Target: ${lblue}$source_dns_record_name${reset}

		Proxy status: ${lblue}DNS only${reset}
		END
		exit 1
	fi

	# We can modify the DNS automatically.

	# If the DNS record doesn't exist, create it.
	if [[ "$dns_record_json" == "null" ]]; then
		printf '%s\n' "Creating DNS record at '$dns_record_name'..."

		local dns_record_data='{"type":"CNAME","name":"'"$dns_record_name"'","content":"'"$source_dns_record_name"'"}'

		cf api "/zones/$zone_id/dns_records" \
			-X POST \
			-H "Content-Type: application/json" \
			--data-raw "$dns_record_data" > /dev/null

		return 0
	fi

	# Since the record already exists, make a request to modify it.

	local dns_record_id
	dns_record_id="$(printf '%s\n' "$dns_record_json" | jq -r '.id')"

	printf '%s\n' "Updating DNS record at '$dns_record_name'..."

	local dns_record_patch='{"content":"'"$source_dns_record_name"'"}'

	cf api "/zones/$zone_id/dns_records/$dns_record_id" \
		-X PATCH \
		-H "Content-Type: application/json" \
		--data-raw "$dns_record_patch" > /dev/null
}

# Ensures the sender's SPF record includes our server's.
_check_spf() {
	# This is our original SPF record that sender's SPF record should
	# include. The name of this record is chosen in our `check_dns` script,
	# where the record is originally created.
	local source_dns_record_name="$source_domain"

	# The name of the DNS record we're checking.
	local dns_record_name="$sender_domain"

	# If the SPF DNS record we're checking is already the source record,
	# there's no need to ensure the former includes the latter.
	if [[ "$dns_record_name" == "$source_dns_record_name" ]]; then
		return 0
	fi

	# This variable will hold information for the SPF record we're checking.
	# If no such record exists, this will be empty.
	local dns_record_json

	# This variable will hold the value of the SPF record we're checking. If
	# no such record exists, this will be empty.
	local spf_data

	# If we have direct DNS access via the Cloudflare API, get the record
	# information from there since it's the most up-to-date source and
	# provides more information about the records that we might need later.
	# If we don't have API access, get it using a DNS query.
	if [[ "$can_access_dns" ]]; then
		dns_record_json="$(get_spf_record "$dns_record_name")"

		spf_data="$(
			printf '%s\n' "$dns_record_json" | jq -r '.content'
		)"
	else
		# To get the SPF value, get all the TXT record values under the
		# sender's domain, remove quotes because quotes are allowed
		# around parts of a TXT record answer's data, and filter the
		# list to only contain records that follow the SPF format
		# defined by RFC 7208 (section 12). If no SPF records are found,
		# do nothing instead of letting `grep` exit with an error.
		spf_data="$(
			cf dns query TXT "$dns_record_name" \
			| jq -r '.Answer[]?.data' \
			| tr -d '"' \
			| { grep -Ei '^v=spf1( |$)' || :; }
		)"

		# Check if there are multiple SPF records.
		if [[ "$spf_data" == *$'\n'* ]]; then
			printf '%s\n' "ERROR: Multiple TXT DNS records starting with 'v=spf1' found at '$dns_record_name'. There must not be multiple SPF records with the same name." >&2
			exit 1
		fi
	fi

	# This will be the value the sender domain's SPF record should have.
	# Start with its existing SPF record value so its preexisting policies
	# (e.g. allowing other mail servers to send for the domain) aren't lost.
	# If there is no existing SPF record, default to an empty SPF policy.
	local correct_spf_data="${spf_data:-v=spf1}"

	# An SPF term that includes our server's own SPF policy into another
	# domain's SPF policy.
	local include="include:$source_dns_record_name"

	# If the sender domain's SPF policy doesn't include our server's own SPF
	# policy, include it so we're allowed to send mail for that domain.
	if ! printf '%s\n' "$correct_spf_data" | grep -Fiqw "$include"; then
		# Insert our `include:` term after the `v=spf1` (starting at
		# index 0, ending 6 characters later) and before the rest of the
		# terms (starting at index 6).
		correct_spf_data="${correct_spf_data:0:6} $include${correct_spf_data:6}"
	fi

	# Remove any preexisting `all` term from the policy, and add the correct
	# one. There should be an `all` term with the `-` (fail) qualifier so
	# all servers not explicitly covered by the policy are disallowed from
	# sending for the domain. Only authorized senders should be allowed.
	#
	# RFC 7208 (section 4.6.2) lists all SPF qualifiers.
	correct_spf_data="$(
		printf '%s\n' "$correct_spf_data" | sed -E 's/ [+-?~]?all$//gi'
	) -all"

	# If the SPF value is already correct, no need to continue.
	if [[ "$spf_data" == "$correct_spf_data" ]]; then
		return 0
	fi

	# If we can't modify the DNS automatically, output an error with
	# instructions to modify it manually.
	if [[ ! "$can_access_dns" ]]; then
		cat <<-END >&2
		ERROR: The following DNS record must be set for ${lblue}$sender_domain${reset}:

		Type: ${lblue}TXT${reset}

		Name: ${lblue}$dns_record_name${reset}

		Content: ${lblue}$correct_spf_data${reset}

		Proxy status: ${lblue}DNS only${reset}
		END
		exit 1
	fi

	# We can modify the DNS automatically.

	# If our SPF record doesn't already exist, create it.
	if [[ ! "$dns_record_json" ]]; then
		printf '%s\n' "Creating DNS record for SPF at '$dns_record_name'..."

		local dns_record_data='{"type":"TXT","name":"'"$dns_record_name"'","content":"'"$correct_spf_data"'"}'

		cf api "/zones/$zone_id/dns_records" \
			-X POST \
			-H "Content-Type: application/json" \
			--data-raw "$dns_record_data" > /dev/null

		return 0
	fi

	# Since the record already exists, make a request to modify it.

	local dns_record_id
	dns_record_id="$(printf '%s\n' "$dns_record_json" | jq -r '.id')"

	printf '%s\n' "Updating DNS record for SPF at '$dns_record_name'..."

	local dns_record_patch='{"content":"'"$correct_spf_data"'"}'

	cf api "/zones/$zone_id/dns_records/$dns_record_id" \
		-X PATCH \
		-H "Content-Type: application/json" \
		--data-raw "$dns_record_patch" > /dev/null
}

# Ensures the sender's DMARC record is set up correctly.
_check_dmarc() {
	# The name of the DMARC record we're checking.
	local dns_record_name="_dmarc.$sender_domain"

	# This variable will hold information for the DMARC record we're
	# checking. If no such record exists, this will be `null`.
	local dns_record_json

	# This variable will hold the value of the DMARC record we're checking.
	# If no such record exists, this will be `null`.
	local dmarc_data

	# If we have direct DNS access via the Cloudflare API, get the record
	# information from there since it's the most up-to-date source and
	# provides more information about the record that we might need later.
	# If we don't have API access, get it using a DNS query.
	if [[ "$can_access_dns" ]]; then
		dns_record_json="$(
			cf api "/zones/$zone_id/dns_records" \
				--url-query "type=TXT" \
				--url-query "name=$dns_record_name" \
			| jq '.result[0]'
		)"

		dmarc_data="$(
			printf '%s\n' "$dns_record_json" | jq -r '.content'
		)"
	else
		dmarc_data="$(
			cf dns query TXT "$dns_record_name" \
			| jq -r '.Answer[0].data'
		)"
	fi

	# This will be the value the sender domain's DMARC record should have.
	local correct_dmarc_data="v=DMARC1;"

	# Use variables to store some regex patterns for matching DMARC data so
	# the variables can be used in place of the patterns later to help make
	# regex a little more readable.
	local wsp=$'[ \t]*'
	local v_tag_pattern="[Vv]${wsp}=${wsp}DMARC1${wsp};"
	local p_tag_start_pattern="${wsp}[Pp]${wsp}=${wsp}"
	local tag_end_pattern="${wsp};"
	local p_tag_pattern="$p_tag_start_pattern[^;]*$tag_end_pattern"

	# If there's an existing DMARC record starting with a valid version tag
	# according to RFC 7489 (section 6.4), use its value as a base for the
	# new value so the existing DMARC configuration isn't lost.
	if printf '%s\n' "$dmarc_data" | grep -q "^$v_tag_pattern"; then
		correct_dmarc_data="$dmarc_data"
	fi

	# Ensure the DMARC record's `p` tag immediately follows the `v` tag as
	# required by RFC 7489 (section 6.4), and ensure it's set to `reject` so
	# unauthorized messages can't be sent on behalf of the sender's domain.
	# Preserve the original case and whitespace wherever possible.
	# * If there's no existing `p` tag, insert the correct one.
	# * Move the `p` tag to be immediately after the `v` tag.
	# * If the `p` tag isn't set to `reject`, set it to `reject`. If
	#   it is, leave it so the original case of "reject" is preserved.
	correct_dmarc_data="$(
		printf '%s\n' "$correct_dmarc_data" \
		| sed -E "
			/;$p_tag_pattern/! s/^($v_tag_pattern)/\1 p=reject;/
			s/^($v_tag_pattern)(.*;)?($p_tag_pattern)/\1\3\2/
			/^$v_tag_pattern$p_tag_start_pattern[Rr][Ee][Jj][Ee][Cc][Tt]$tag_end_pattern/! s/;($p_tag_start_pattern)[^;]*($tag_end_pattern)/;\1reject\2/
		"
	)"

	# If the DMARC value is already correct, no need to continue.
	if [[ "$dmarc_data" == "$correct_dmarc_data" ]]; then
		return 0
	fi

	# If we can't modify the DNS automatically, output an error with
	# instructions to modify it manually.
	if [[ ! "$can_access_dns" ]]; then
		cat <<-END >&2
		ERROR: The following DNS record must be set for ${lblue}$sender_domain${reset}:

		Type: ${lblue}TXT${reset}

		Name: ${lblue}$dns_record_name${reset}

		Content: ${lblue}$correct_dmarc_data${reset}

		Proxy status: ${lblue}DNS only${reset}
		END
		exit 1
	fi

	# We can modify the DNS automatically.

	# If our DMARC record doesn't already exist, create it.
	if [[ "$dns_record_json" == "null" ]]; then
		printf '%s\n' "Creating DNS record for DMARC at '$dns_record_name'..."

		local dns_record_data='{"type":"TXT","name":"'"$dns_record_name"'","content":"'"$correct_dmarc_data"'"}'

		cf api "/zones/$zone_id/dns_records" \
			-X POST \
			-H "Content-Type: application/json" \
			--data-raw "$dns_record_data" > /dev/null

		return 0
	fi

	# Since the record already exists, make a request to modify it.

	local dns_record_id
	dns_record_id="$(printf '%s\n' "$dns_record_json" | jq -r '.id')"

	printf '%s\n' "Updating DNS record for DMARC at '$dns_record_name'..."

	local dns_record_patch='{"content":"'"$correct_dmarc_data"'"}'

	cf api "/zones/$zone_id/dns_records/$dns_record_id" \
		-X PATCH \
		-H "Content-Type: application/json" \
		--data-raw "$dns_record_patch" > /dev/null
}

# Ensure the sender's domain points to both of our DKIM keys.
_check_dkim a
_check_dkim b

# Ensure the sender's domain points to our SPF policy.
_check_spf

# Ensure the sender's domain has DMARC set up correctly.
_check_dmarc
