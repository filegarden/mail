#!/bin/busybox sh

# Exit if an error occurs or an unset variable is referenced.
set -euo pipefail

# Checks the SPF DNS record for our hostname.
_check_hostname_spf() {
	printf '%s\n' "Checking SPF..."

	# Obtain this server's public IP addresses to use in our SPF DNS record.
	# If either request fails, do nothing instead of exiting, because it's
	# expected that some networks don't support both IPv4 and IPv6.
	local ipv4 ipv6
	ipv4="$(curl -s --ipv4 https://icanhazip.com/ || :)"
	ipv6="$(curl -s --ipv6 https://icanhazip.com/ || :)"

	# If no IPs are found, something is wrong, and we won't be able to add
	# this server as an allowed sender in our SPF record.
	if [[ ! "$ipv4$ipv6" ]]; then
		printf '%s\n' "ERROR: Could not obtain your public IP address (to include in your SPF record)." >&2
		return 1
	fi

	# Get our Cloudflare zone information.
	local zone_json zone_name zone_id
	zone_json="$(cf zone)"
	zone_name="$(printf '%s\n' "$zone_json" | jq -r '.name')"
	zone_id="$(printf '%s\n' "$zone_json" | jq -r '.id')"

	# Get our mail server's hostname (e.g. `mail.example.com`).
	local hostname
	hostname="$(hostname)"

	# The DNS record that should contain our SPF policy.
	local record_name="$hostname"

	# If our mail server's hostname (`$hostname`) is outside the domain of
	# the zone our token has access to (`$zone_name`), correct the record
	# name to be under our zone.
	if [[ ".$hostname" != *".$zone_name" ]]; then
		record_name="$record_name.$zone_name"
	fi

	# Start generating the value that the SPF record should have.
	local correct_record_content="v=spf1"

	# Add our server's IP addresses to our SPF record as allowed senders.
	if [[ "$ipv4" ]]; then
		correct_record_content="$correct_record_content ip4:$ipv4"
	fi
	if [[ "$ipv6" ]]; then
		correct_record_content="$correct_record_content ip6:$ipv6"
	fi

	# Disallow all other senders. Only our mail server should be able to
	# send as our mail server.
	#
	# Note that, as per RFC 7208 (section 5.2), this has no effect on other
	# SPF records that `include:` this one, which is good for domains that
	# want to allow multiple mail servers (including ours) to send as them.
	correct_spf_data="$correct_spf_data -all"

	# Fetch our server's existing SPF record. If there is none, this will be
	# empty.
	local record_json
	record_json="$(get_spf_record "$record_name")"

	# If our SPF record doesn't already exist, create it.
	if [[ ! "$record_json" ]]; then
		printf '%s\n' "Creating DNS record for SPF at '$record_name'..."

		local record_data='{"type":"TXT","name":"'"$record_name"'","content":"'"$correct_spf_data"'"}'

		cf api "/zones/$zone_id/dns_records" \
			-X POST \
			-H "Content-Type: application/json" \
			--data-raw "$record_data" > /dev/null

		return 0
	fi

	# Since the record already exists, make a request to modify it if
	# necessary.

	# Get the SPF record's current value.
	local spf_data
	spf_data="$(printf '%s\n' "$record_json" | jq -r '.content')"

	# If the SPF record already has the correct value, no need to continue
	# with updating it.
	if [[ "$spf_data" == "$correct_spf_data" ]]; then
		return 0
	fi

	# Update the existing SPF record to have the correct value.

	# Get the ID of the existing SPF record.
	local record_id
	record_id="$(printf '%s\n' "$record_json" | jq -r '.id')"

	printf '%s\n' "Updating DNS record for SPF at '$record_name'..."

	local record_patch='{"content":"'"$correct_spf_data"'"}'

	cf api "/zones/$zone_id/dns_records/$record_id" \
		-X PATCH \
		-H "Content-Type: application/json" \
		--data-raw "$record_patch" > /dev/null
}

# Checks the DNS records for all the domains of the addresses in our password
# database to ensure we're allowed to send as them.
_check_sender_domains() {
	user domains \
	| while read -r sender_domain; do
		printf '%s\n' "Checking DNS for sender domain '$sender_domain'..."

		check_sender_dns "$sender_domain"
	done
}

_check_hostname_spf
_check_sender_domains
