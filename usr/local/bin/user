#!/bin/busybox sh

# Exit if an error occurs or an unset variable is referenced.
set -euo pipefail

# By default, don't let unprivileged users access files created by this script.
umask 0077

reset="$(printf '\e[0m')"
gray="$(printf '\e[90m')"
lblue="$(printf '\e[1;34m')"

# Our Dovecot password database path (from `etc/dovecot/conf.d/10-auth.conf`).
passdb=/etc/auth/passwd

# If the previous pipeline exits with status 141 due to a command being piped
# into something that exits early, this catches and ignores the error.
_ignore_sigpipe() {
	local status="$?"
	if [[ "$status" != "141" ]]; then
		return "$status"
	fi
}

# Saves the file at the specified path as the new password database.
_save_passdb() {
	local temp_passdb="$1"

	# Copy the current database file's permissions to the new database file.
	local passdb_mod passdb_own
	passdb_mod="$(stat -c '%a' -- "$passdb")"
	passdb_own="$(stat -c '%u:%g' -- "$passdb")"
	chmod -- "$passdb_mod" "$temp_passdb"
	chown -- "$passdb_own" "$temp_passdb"

	# Save the database.
	mv -f -- "$temp_passdb" "$passdb"
}

# Adds an address to the password database and generates a crytographically
# secure pseudorandom password for it, printing the new password. Exits with an
# error if the specified address is already in the database.
add() {
	local address="$1"

	# Ensure the address doesn't already exist before adding it.
	if user exists "$address"; then
		printf '%s\n' "Address '$address' already exists in database." \
			>&2
		exit 1
	fi

	# Check if the specified address is invalid.
	if [[ "$address" != *"@"* ]]; then
		printf '%s\n' "Invalid address: $address" >&2
		exit 1
	fi

	# Generate a cryptographically secure pseudorandom password in Base64.
	# We generate 192 bytes because that encodes into 256 Base64 characters,
	# which is as close as Base64 can get to 255, the maximum SASL password
	# length as per RFC 4616 (section 2). Then cut the password off at that
	# maximum length.
	local password
	password="$(openssl rand 192 | openssl base64 -A | cut -c -255)"

	# Hash the password using Argon2.
	local password_hash
	password_hash="$(doveadm pw -s ARGON2ID -p "$password")"

	# Use a temporary file for writing to the password database to prevent
	# corrupting the original in case of a failure.
	local temp_passdb
	temp_passdb="$(mktemp -u)"
	cp -- "$passdb" "$temp_passdb"

	# Append the new user entry to the database.
	printf '%s\n' "$address:$password_hash" >> "$temp_passdb"

	# Save the database.
	_save_passdb "$temp_passdb"

	# Get our mail server's hostname (e.g. `mail.example.com`).
	local hostname
	hostname="$(hostname)"

	cat <<-END
	Log into your mail server using these SASL credentials.

	${gray}To learn how to sign into your mail server using these credentials, see:
	https://github.com/filegarden/mail/blob/main/README.md${reset}

	Hostname: ${lblue}$hostname${reset}

	Login Name: ${lblue}$address${reset}

	Password:
	${lblue}$password${reset}
	END
}

# Removes an address and its password from the password database. Exits with an
# error if the specified address isn't in the database.
remove() {
	local address="$1"

	# Ensure the address exists before removing it.
	if ! user exists "$address"; then
		printf '%s\n' "Address '$address' not found in database." >&2
		exit 1
	fi

	# Use a temporary file for writing to the password database to prevent
	# corrupting the original in case of a failure.
	local temp_passdb
	temp_passdb="$(mktemp -u)"

	# Escape the address so it can be safely used in a regex pattern.
	local escaped_address
	escaped_address="$(printf '%s\n' "$address" | sed 's/[$*./[\^]/\\&/g')"

	# Remove the specified address from the database.
	sed "/^$escaped_address:/d" -- "$passdb" > "$temp_passdb"

	# Save the password database.
	_save_passdb "$temp_passdb"

	printf '%s\n' "Removed '$address' from database."
}

# Generates a new crytographically secure pseudorandom password for an address
# in the password database and prints the new password. Exits with an error if
# the specified address isn't in the database.
reset() {
	local address="$1"

	# Remove the existing user from the password database. Hide the removal
	# success message since it doesn't make sense for resetting a password.
	user remove "$address" > /dev/null

	# Now that it's removed, add a new user under the same address. It will
	# get a fresh password.
	user add "$address"
}

# Lists all addresses in the password database, one per line.
list() {
	# Output the `user` part of each `user:password` line from the database
	# file.
	cut -d : -f 1 -- "$passdb"
}

# If an address exists in the password database, exits with status 0. Otherwise,
# exits with status 1.
exists() {
	local address="$1"

	user list | grep -Fqxe "$address" || _ignore_sigpipe
}

case "$1" in
add | remove | reset | list | exists)
	"$@"
	;;
*)
	printf '%s\n' "Invalid subcommand '$1'."
	exit 1
	;;
esac
