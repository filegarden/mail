#!/bin/busybox sh

# Exit if an error occurs or an unset variable is referenced.
set -euo pipefail

# Makes a request to the Cloudflare API.
api() {
	local path="$1"
	# Shift off `$1` from this function's arguments so `$@` can refer to all
	# the arguments except `$path`.
	shift

	local cf_api_base_url=https://api.cloudflare.com/client/v4

	# Load the Cloudflare API token from our `.env` file.
	local cf_api_token
	cf_api_token="$(cat /run/.env/CF_API_TOKEN)"

	local response_json
	response_json="$(
		# Make the HTTP request to Cloudflare's API using `curl`, with
		# all of this function's arguments passed in.
		curl -LSs \
			-H "Authorization: Bearer $cf_api_token" \
			"$@" \
			-- "$cf_api_base_url$path"
	)" || exit 1

	# Output any errors from the API response.
	printf '%s\n' "$response_json" | jq -cr '.errors[]' \
	| while read -r error; do
		printf '%s\n' "ERROR (Cloudflare API): $error" >&2
	done

	# If the request wasn't successful, exit the script.
	if [[ "$(printf '%s\n' "$response_json" | jq '.success')" != "true" ]]
	then
		exit 1
	fi

	# The request was successful, so output the response JSON.
	printf '%s\n' "$response_json"
}

# Gets the JSON value of the zone the Cloudflare API token has access to. If the
# API token doesn't have access to exactly one zone, this returns an error.
#
# Note that which zone this returns can change without restarting the container
# if the token's permissions are edited in Cloudflare.
zone() {
	# Get JSON values for all the zones the token has access to.
	local zone_jsons
	zone_jsons="$(cf api /zones | jq -cr '.result[]')" || exit 1

	# Check if the token doesn't have access to any zones.
	if [[ -z "$zone_jsons" ]]; then
		printf '%s\n' "ERROR: Your Cloudflare API token cannot access any zones. Please enable its permission to edit DNS for a zone." >&2
		exit 1
	fi

	# Check if the token has access to multiple zones.
	if [[ "$zone_jsons" == *$'\n'* ]]; then
		printf '%s\n' "ERROR: Your Cloudflare API token can access multiple zones, which is insecure. Please restrict its permissions so it can only edit DNS for a single zone." >&2
		exit 1
	fi

	# Now that we're sure there's only one zone, output it.
	printf '%s\n' "$zone_jsons"
}

# Calls one of the below DNS functions.
dns() {
	local subcommand="$1"
	shift

	case "$subcommand" in
	query | purge)
		"dns_$subcommand" "$@"
		;;
	*)
		exit 1
		;;
	esac
}

# Makes a query to Cloudflare's DNS.
dns_query() {
	local type="$1" name="$2"

	# Refresh Cloudflare's DNS cache for the record we're querying so we get
	# the most updated answer.
	cf dns purge "$type" "$name"

	curl -LSs -X GET https://cloudflare-dns.com/dns-query \
		--url-query "type=$type" \
		--url-query "name=$name" \
		-H "Accept: application/dns-json" \
		--fail-with-body
}

# Refreshes Cloudflare's DNS cache.
dns_purge() {
	local type="$1" domain="$2"

	curl -LSs -X POST https://cloudflare-dns.com/api/v1/purge \
		--url-query "type=$type" \
		--url-query "domain=$domain" \
		--fail-with-body > /dev/null
}

case "$1" in
api | zone | dns)
	"$@"
	;;
*)
	exit 1
	;;
esac
