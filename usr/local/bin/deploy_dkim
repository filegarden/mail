#!/bin/busybox sh

# Exit if an error occurs or an unset variable is referenced.
set -euo pipefail

# Exits with an error if this script isn't running with root privileges.
_require_root() {
	if [[ "$(id -u)" != "0" ]]; then
		printf '%s\n' "Root user privileges required." >&2
		exit 1
	fi
}

# Reloads OpenDKIM.
_reload_opendkim() {
	# Get OpenDKIM's process ID and then its main child process's ID.
	opendkim_pid="$(cat /run/opendkim.pid)"
	opendkim_child_pid="$(pgrep -P "$opendkim_pid")"

	# Kill the child process so OpenDKIM restarts it. (Don't worry; this
	# allows it to exit cleanly.)
	kill -- "$opendkim_child_pid"
}

# Deploys our DKIM key files to the location OpenDKIM reads them from. This
# requires root privileges because OpenDKIM outputs security warnings if any
# user but `opendkim` can access these files (even though they're initially
# written by `dkim`, a different user, before being deployed).
files() {
	_require_root

	# Set the path where our `home/dkim/bin/rotate` script outputs our
	# private keys.
	source_path=/home/dkim/keys

	# Set the path where OpenDKIM looks for private key files, as set in the
	# `KeyFile` option from `etc/opendkim/opendkim.conf`.
	target_path=/var/db/dkim

	# Get the name of the most recent key to use as our active DKIM key.
	active_key="$(
		find "$source_path" -mindepth 1 -maxdepth 1 \
			-exec ls -1t -- {} + \
		| head -n 1 \
		| xargs -r basename -s .pem --
	)" || exit 1

	# Copy the contents of the active key file to OpenDKIM's directory.
	cat -- "$source_path/$active_key.pem" > "$target_path/key.pem"

	# Tell OpenDKIM the active key is the key it should use. The below `*`
	# means to sign messages from all domains. We configured Postfix to only
	# give OpenDKIM messages from trusted senders, so this is fine.
	printf '%s\n' "* $active_key" > "$target_path/SigningTable"
}

# Listens for calls to the `notify` function in order to deploy updated DKIM
# keys. This requires root privileges.
listen() {
	_require_root

	# Create the named pipe we'll use to let the `notify` function
	# communicate with this function.
	mkfifo -m 0620 /run/deploy_dkim.fifo

	# Give the unprivileged `dkim` user permission to call `notify` and
	# deploy our DKIM keys.
	chgrp dkim /run/deploy_dkim.fifo

	# Repeatedly do the following forever.
	while true; do
		# Open the below named pipe for reading. This script is blocked
		# and cannot continue until `notify` opens and closes the pipe
		# for writing. We don't care about any data written to the pipe,
		# only that it's opened, so discard any data that comes through.
		cat /run/deploy_dkim.fifo > /dev/null

		# Give the updated DKIM files to OpenDKIM.
		deploy_dkim files

		# Reload OpenDKIM so it can use the updated files.
		_reload_opendkim
	done
}

# Notifies the `listen` function to deploy our DKIM keys, since they've been
# updated. This can't deploy updated keys directly because doing so requires
# root privileges, and this should be ran by an unprivileged user.
notify() {
	# Check if the `listen` function is running yet by checking if the named
	# pipe it creates exists.
	if [[ -e /run/deploy_dkim.fifo ]]; then
		# Open and close the pipe for writing, unblocking the `listen`
		# function.
		printf '' > /run/deploy_dkim.fifo
	fi
}

case "$1" in
files | listen | notify)
	"$@"
	;;
*)
	exit 1
	;;
esac
